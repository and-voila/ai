# Code generated by "wunderctl"; DO NOT EDIT.

schema {
  query: Query
  mutation: Mutation
}

"""
The @removeNullVariables directive allows you to remove variables with null value from your GraphQL Query or Mutation Operations.

A potential use-case could be that you have a graphql upstream which is not accepting null values for variables.
By enabling this directive all variables with null values will be removed from upstream query.

query ($say: String, $name: String) @removeNullVariables {
	hello(say: $say, name: $name)
}

Directive will transform variables json and remove top level null values.
{ "say": null, "name": "world" }

So upstream will receive the following variables:

{ "name": "world" }
"""
directive @removeNullVariables on QUERY | MUTATION

directive @hooksVariable on VARIABLE_DEFINITION

directive @jsonSchema(
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  title: String
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  description: String
  """
  The value of "multipleOf" MUST be a number, strictly greater than 0.
  
  A numeric instance is valid only if division by this keyword's value
  results in an integer.
  """
  multipleOf: Int
  """
  The value of "maximum" MUST be a number, representing an inclusive
  upper limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is less than or exactly equal to "maximum".
  """
  maximum: Int
  """
  The value of "exclusiveMaximum" MUST be number, representing an
  exclusive upper limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly less than (not equal to) "exclusiveMaximum".
  """
  exclusiveMaximum: Int
  """
  The value of "minimum" MUST be a number, representing an inclusive
  lower limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is greater than or exactly equal to "minimum".
  """
  minimum: Int
  """
  The value of "exclusiveMinimum" MUST be number, representing an
  exclusive lower limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly greater than (not equal to) "exclusiveMinimum".
  """
  exclusiveMinimum: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is less
  than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  """
  maxLength: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is
  greater than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minLength: Int
  """
  The value of this keyword MUST be a string.  This string SHOULD be a
  valid regular expression, according to the ECMA 262 regular
  expression dialect.
  
  A string instance is considered valid if the regular expression
  matches the instance successfully.  Recall: regular expressions are
  not implicitly anchored.
  """
  pattern: String
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "maxItems" if its size is less
  than, or equal to, the value of this keyword.
  """
  maxItems: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "minItems" if its size is greater
  than, or equal to, the value of this keyword.
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minItems: Int
  """
  The value of this keyword MUST be a boolean.
  
  If this keyword has boolean value false, the instance validates
  successfully.  If it has boolean value true, the instance validates
  successfully if all of its elements are unique.
  
  Omitting this keyword has the same behavior as a value of false.
  """
  uniqueItems: Boolean
  commonPattern: COMMON_REGEX_PATTERN
  """Optional field to apply the JSON schema to"""
  on: String
) repeatable on VARIABLE_DEFINITION

directive @rbac(
  "the user must match all roles"
  requireMatchAll: [WG_ROLE]
  "the user must match at least one of the roles"
  requireMatchAny: [WG_ROLE]
  "the user must not match all of the roles"
  denyMatchAll: [WG_ROLE]
  "the user must not match any of the roles"
  denyMatchAny: [WG_ROLE]
) on QUERY | MUTATION | SUBSCRIPTION

"""
The @fromClaim directive sets the variable to the value retrieved from the given a claim.
Adding this directive makes the operation require authentication.
"""
directive @fromClaim(name: WG_CLAIM, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The directive @injectCurrentDateTime injects a DateTime string of the current date and time into the variable.
This variable MUST be a string compatible scalar. 

The default format, is: ISO 8601
If no format is chosen, the default format is used.
Custom formats are allowed by specifying a format conforming to the Golang specification for specifying a date time format.
"""
directive @injectCurrentDateTime(
  format: WunderGraphDateTimeFormat = ISO8601
  """
  customFormat must conform to the Golang specification for specifying a date time format
  """
  customFormat: String
  on: String = ""
) repeatable on VARIABLE_DEFINITION

"""
The directive @injectGeneratedUUID injects a generated UUID into the variable.
This variable MUST be a string.
At the same time, it removes the variable from the input definition,
disallowing the user to supply it.

This means, the UUID is 100% generated server-side and can be considered untempered.
"""
directive @injectGeneratedUUID(on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @internalOperation Directive marks an Operation as internal.
By doing so, the Operation is no longer accessible from the public API.
It can only be accessed by internal services, like hooks.
"""
directive @internalOperation on QUERY | MUTATION | SUBSCRIPTION

"""
The directive @injectEnvironmentVariable allows you to inject an environment variable into the variable definition.
"""
directive @injectEnvironmentVariable(name: String!, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @export directive instructs the Execution Planner to export the field during the execution into the variable of the 'as' argument.
As the execution is depth first, a field can only be used after it has been exported.
Additionally, a field can only be used after using the '_join' field or on a different data source.
It's not possible to export a field and use it in for the same data source.

Note that the @export directive only works on fields that return a single value.
It's not possible to export a list or object field.
"""
directive @export(
  """The argument 'as' is the name of the variable to export the field to."""
  as: String!
) on FIELD

"""
The directive @internal marks a variable definition as internal so that clients can't access it.
The field is also not visible in the public API.
It's only being used as an internal variable to export fields into.
"""
directive @internal on VARIABLE_DEFINITION

"""
The @transform directive allows to apply transformations to the response.
By applying the directive, the shape of the response can be altered,
which will also modify the JSON-Schema of the response.
That is, you will keep full type safety and code-generation for transformed fields.
"""
directive @transform(
  """
  Using the 'get' transformation allows you to extract a nested field using a JSON path.
  This is useful to unnest data, e.g. when using the '_join' field, which adds an extra layer of nesting.
  
  Example:
  
  query GetName {
      name: me @transform(get: "info.name") {
          info {
              name
          }
      }
  }
  
  Before the transformation, the resolve looks like this:
  
  {
      "name": {
          "info": {
              "name": "John Doe"
          }
      }
  }
  
  With the transformation applied, the response will be reshaped like this:
  
  {
      "name": "John Doe"
  }
  """
  get: String
) on FIELD

"""
The @requireAuthentication Directive marks an Operation to require authentication.
Without authentication, the operation will return an Unauthorized error with status code 401.
"""
directive @requireAuthentication on QUERY | MUTATION | SUBSCRIPTION

enum prisma_QueryMode {
  default
  insensitive
}

input prisma_NestedStringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: prisma_NestedStringFilter
}

input prisma_StringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: prisma_QueryMode
  not: prisma_NestedStringFilter
}

input prisma_NestedIntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: prisma_NestedIntFilter
}

input prisma_IntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: prisma_NestedIntFilter
}

input prisma_NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeFilter
}

input prisma_DateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeFilter
}

input prisma_UserApiLimitWhereInput {
  AND: prisma_UserApiLimitWhereInput
  OR: [prisma_UserApiLimitWhereInput]
  NOT: prisma_UserApiLimitWhereInput
  id: prisma_StringFilter
  userId: prisma_StringFilter
  count: prisma_IntFilter
  createdAt: prisma_DateTimeFilter
  updatedAt: prisma_DateTimeFilter
}

enum prisma_SortOrder {
  asc
  desc
}

input prisma_UserApiLimitOrderByWithRelationInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  count: prisma_SortOrder
  createdAt: prisma_SortOrder
  updatedAt: prisma_SortOrder
}

input prisma_UserApiLimitWhereUniqueInput {
  id: String
  userId: String
}

enum prisma_UserApiLimitScalarFieldEnum {
  id
  userId
  count
  createdAt
  updatedAt
}

type prisma_UserApiLimit {
  id: String!
  userId: String!
  count: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  _join: Query!
}

type prisma_UserApiLimitCountAggregateOutputType {
  id: Int!
  userId: Int!
  count: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
  _join: Query!
}

type prisma_UserApiLimitAvgAggregateOutputType {
  count: Float
  _join: Query!
}

type prisma_UserApiLimitSumAggregateOutputType {
  count: Int
  _join: Query!
}

type prisma_UserApiLimitMinAggregateOutputType {
  id: String
  userId: String
  count: Int
  createdAt: DateTime
  updatedAt: DateTime
  _join: Query!
}

type prisma_UserApiLimitMaxAggregateOutputType {
  id: String
  userId: String
  count: Int
  createdAt: DateTime
  updatedAt: DateTime
  _join: Query!
}

type prisma_AggregateUserApiLimit {
  _count: prisma_UserApiLimitCountAggregateOutputType
  _avg: prisma_UserApiLimitAvgAggregateOutputType
  _sum: prisma_UserApiLimitSumAggregateOutputType
  _min: prisma_UserApiLimitMinAggregateOutputType
  _max: prisma_UserApiLimitMaxAggregateOutputType
  _join: Query!
}

input prisma_UserApiLimitCountOrderByAggregateInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  count: prisma_SortOrder
  createdAt: prisma_SortOrder
  updatedAt: prisma_SortOrder
}

input prisma_UserApiLimitAvgOrderByAggregateInput {
  count: prisma_SortOrder
}

input prisma_UserApiLimitMaxOrderByAggregateInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  count: prisma_SortOrder
  createdAt: prisma_SortOrder
  updatedAt: prisma_SortOrder
}

input prisma_UserApiLimitMinOrderByAggregateInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  count: prisma_SortOrder
  createdAt: prisma_SortOrder
  updatedAt: prisma_SortOrder
}

input prisma_UserApiLimitSumOrderByAggregateInput {
  count: prisma_SortOrder
}

input prisma_UserApiLimitOrderByWithAggregationInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  count: prisma_SortOrder
  createdAt: prisma_SortOrder
  updatedAt: prisma_SortOrder
  _count: prisma_UserApiLimitCountOrderByAggregateInput
  _avg: prisma_UserApiLimitAvgOrderByAggregateInput
  _max: prisma_UserApiLimitMaxOrderByAggregateInput
  _min: prisma_UserApiLimitMinOrderByAggregateInput
  _sum: prisma_UserApiLimitSumOrderByAggregateInput
}

input prisma_NestedStringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: prisma_NestedStringWithAggregatesFilter
  _count: prisma_NestedIntFilter
  _min: prisma_NestedStringFilter
  _max: prisma_NestedStringFilter
}

input prisma_StringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: prisma_QueryMode
  not: prisma_NestedStringWithAggregatesFilter
  _count: prisma_NestedIntFilter
  _min: prisma_NestedStringFilter
  _max: prisma_NestedStringFilter
}

input prisma_NestedFloatFilter {
  equals: Float
  in: [Float]
  notIn: [Float]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: prisma_NestedFloatFilter
}

input prisma_NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: prisma_NestedIntWithAggregatesFilter
  _count: prisma_NestedIntFilter
  _avg: prisma_NestedFloatFilter
  _sum: prisma_NestedIntFilter
  _min: prisma_NestedIntFilter
  _max: prisma_NestedIntFilter
}

input prisma_IntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: prisma_NestedIntWithAggregatesFilter
  _count: prisma_NestedIntFilter
  _avg: prisma_NestedFloatFilter
  _sum: prisma_NestedIntFilter
  _min: prisma_NestedIntFilter
  _max: prisma_NestedIntFilter
}

input prisma_NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeWithAggregatesFilter
  _count: prisma_NestedIntFilter
  _min: prisma_NestedDateTimeFilter
  _max: prisma_NestedDateTimeFilter
}

input prisma_DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeWithAggregatesFilter
  _count: prisma_NestedIntFilter
  _min: prisma_NestedDateTimeFilter
  _max: prisma_NestedDateTimeFilter
}

input prisma_UserApiLimitScalarWhereWithAggregatesInput {
  AND: prisma_UserApiLimitScalarWhereWithAggregatesInput
  OR: [prisma_UserApiLimitScalarWhereWithAggregatesInput]
  NOT: prisma_UserApiLimitScalarWhereWithAggregatesInput
  id: prisma_StringWithAggregatesFilter
  userId: prisma_StringWithAggregatesFilter
  count: prisma_IntWithAggregatesFilter
  createdAt: prisma_DateTimeWithAggregatesFilter
  updatedAt: prisma_DateTimeWithAggregatesFilter
}

type prisma_UserApiLimitGroupByOutputType {
  id: String!
  userId: String!
  count: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  _count: prisma_UserApiLimitCountAggregateOutputType
  _avg: prisma_UserApiLimitAvgAggregateOutputType
  _sum: prisma_UserApiLimitSumAggregateOutputType
  _min: prisma_UserApiLimitMinAggregateOutputType
  _max: prisma_UserApiLimitMaxAggregateOutputType
  _join: Query!
}

input prisma_NestedStringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: prisma_NestedStringNullableFilter
}

input prisma_StringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: prisma_QueryMode
  not: prisma_NestedStringNullableFilter
}

input prisma_NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeNullableFilter
}

input prisma_DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeNullableFilter
}

input prisma_UserSubscriptionWhereInput {
  AND: prisma_UserSubscriptionWhereInput
  OR: [prisma_UserSubscriptionWhereInput]
  NOT: prisma_UserSubscriptionWhereInput
  id: prisma_StringFilter
  userId: prisma_StringFilter
  stripeCustomerId: prisma_StringNullableFilter
  stripeSubscriptionId: prisma_StringNullableFilter
  stripePriceId: prisma_StringNullableFilter
  stripeCurrentPeriodEnd: prisma_DateTimeNullableFilter
}

input prisma_UserSubscriptionOrderByWithRelationInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  stripeCustomerId: prisma_SortOrder
  stripeSubscriptionId: prisma_SortOrder
  stripePriceId: prisma_SortOrder
  stripeCurrentPeriodEnd: prisma_SortOrder
}

input prisma_UserSubscriptionWhereUniqueInput {
  id: String
  userId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
}

enum prisma_UserSubscriptionScalarFieldEnum {
  id
  userId
  stripeCustomerId
  stripeSubscriptionId
  stripePriceId
  stripeCurrentPeriodEnd
}

type prisma_UserSubscription {
  id: String!
  userId: String!
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _join: Query!
}

type prisma_UserSubscriptionCountAggregateOutputType {
  id: Int!
  userId: Int!
  stripeCustomerId: Int!
  stripeSubscriptionId: Int!
  stripePriceId: Int!
  stripeCurrentPeriodEnd: Int!
  _all: Int!
  _join: Query!
}

type prisma_UserSubscriptionMinAggregateOutputType {
  id: String
  userId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _join: Query!
}

type prisma_UserSubscriptionMaxAggregateOutputType {
  id: String
  userId: String
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _join: Query!
}

type prisma_AggregateUserSubscription {
  _count: prisma_UserSubscriptionCountAggregateOutputType
  _min: prisma_UserSubscriptionMinAggregateOutputType
  _max: prisma_UserSubscriptionMaxAggregateOutputType
  _join: Query!
}

input prisma_UserSubscriptionCountOrderByAggregateInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  stripeCustomerId: prisma_SortOrder
  stripeSubscriptionId: prisma_SortOrder
  stripePriceId: prisma_SortOrder
  stripeCurrentPeriodEnd: prisma_SortOrder
}

input prisma_UserSubscriptionMaxOrderByAggregateInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  stripeCustomerId: prisma_SortOrder
  stripeSubscriptionId: prisma_SortOrder
  stripePriceId: prisma_SortOrder
  stripeCurrentPeriodEnd: prisma_SortOrder
}

input prisma_UserSubscriptionMinOrderByAggregateInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  stripeCustomerId: prisma_SortOrder
  stripeSubscriptionId: prisma_SortOrder
  stripePriceId: prisma_SortOrder
  stripeCurrentPeriodEnd: prisma_SortOrder
}

input prisma_UserSubscriptionOrderByWithAggregationInput {
  id: prisma_SortOrder
  userId: prisma_SortOrder
  stripeCustomerId: prisma_SortOrder
  stripeSubscriptionId: prisma_SortOrder
  stripePriceId: prisma_SortOrder
  stripeCurrentPeriodEnd: prisma_SortOrder
  _count: prisma_UserSubscriptionCountOrderByAggregateInput
  _max: prisma_UserSubscriptionMaxOrderByAggregateInput
  _min: prisma_UserSubscriptionMinOrderByAggregateInput
}

input prisma_NestedIntNullableFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: prisma_NestedIntNullableFilter
}

input prisma_NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: prisma_NestedStringNullableWithAggregatesFilter
  _count: prisma_NestedIntNullableFilter
  _min: prisma_NestedStringNullableFilter
  _max: prisma_NestedStringNullableFilter
}

input prisma_StringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: prisma_QueryMode
  not: prisma_NestedStringNullableWithAggregatesFilter
  _count: prisma_NestedIntNullableFilter
  _min: prisma_NestedStringNullableFilter
  _max: prisma_NestedStringNullableFilter
}

input prisma_NestedDateTimeNullableWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeNullableWithAggregatesFilter
  _count: prisma_NestedIntNullableFilter
  _min: prisma_NestedDateTimeNullableFilter
  _max: prisma_NestedDateTimeNullableFilter
}

input prisma_DateTimeNullableWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: prisma_NestedDateTimeNullableWithAggregatesFilter
  _count: prisma_NestedIntNullableFilter
  _min: prisma_NestedDateTimeNullableFilter
  _max: prisma_NestedDateTimeNullableFilter
}

input prisma_UserSubscriptionScalarWhereWithAggregatesInput {
  AND: prisma_UserSubscriptionScalarWhereWithAggregatesInput
  OR: [prisma_UserSubscriptionScalarWhereWithAggregatesInput]
  NOT: prisma_UserSubscriptionScalarWhereWithAggregatesInput
  id: prisma_StringWithAggregatesFilter
  userId: prisma_StringWithAggregatesFilter
  stripeCustomerId: prisma_StringNullableWithAggregatesFilter
  stripeSubscriptionId: prisma_StringNullableWithAggregatesFilter
  stripePriceId: prisma_StringNullableWithAggregatesFilter
  stripeCurrentPeriodEnd: prisma_DateTimeNullableWithAggregatesFilter
}

type prisma_UserSubscriptionGroupByOutputType {
  id: String!
  userId: String!
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
  _count: prisma_UserSubscriptionCountAggregateOutputType
  _min: prisma_UserSubscriptionMinAggregateOutputType
  _max: prisma_UserSubscriptionMaxAggregateOutputType
  _join: Query!
}

type Query {
  prisma_findFirstUserApiLimit(where: prisma_UserApiLimitWhereInput, orderBy: [prisma_UserApiLimitOrderByWithRelationInput], cursor: prisma_UserApiLimitWhereUniqueInput, take: Int, skip: Int, distinct: [prisma_UserApiLimitScalarFieldEnum]): prisma_UserApiLimit
  prisma_findFirstUserApiLimitOrThrow(where: prisma_UserApiLimitWhereInput, orderBy: [prisma_UserApiLimitOrderByWithRelationInput], cursor: prisma_UserApiLimitWhereUniqueInput, take: Int, skip: Int, distinct: [prisma_UserApiLimitScalarFieldEnum]): prisma_UserApiLimit
  prisma_findManyUserApiLimit(where: prisma_UserApiLimitWhereInput, orderBy: [prisma_UserApiLimitOrderByWithRelationInput], cursor: prisma_UserApiLimitWhereUniqueInput, take: Int, skip: Int, distinct: [prisma_UserApiLimitScalarFieldEnum]): [prisma_UserApiLimit]!
  prisma_aggregateUserApiLimit(where: prisma_UserApiLimitWhereInput, orderBy: [prisma_UserApiLimitOrderByWithRelationInput], cursor: prisma_UserApiLimitWhereUniqueInput, take: Int, skip: Int): prisma_AggregateUserApiLimit!
  prisma_groupByUserApiLimit(where: prisma_UserApiLimitWhereInput, orderBy: [prisma_UserApiLimitOrderByWithAggregationInput], by: [prisma_UserApiLimitScalarFieldEnum]!, having: prisma_UserApiLimitScalarWhereWithAggregatesInput, take: Int, skip: Int): [prisma_UserApiLimitGroupByOutputType]!
  prisma_findUniqueUserApiLimit(where: prisma_UserApiLimitWhereUniqueInput!): prisma_UserApiLimit
  prisma_findUniqueUserApiLimitOrThrow(where: prisma_UserApiLimitWhereUniqueInput!): prisma_UserApiLimit
  prisma_findFirstUserSubscription(where: prisma_UserSubscriptionWhereInput, orderBy: [prisma_UserSubscriptionOrderByWithRelationInput], cursor: prisma_UserSubscriptionWhereUniqueInput, take: Int, skip: Int, distinct: [prisma_UserSubscriptionScalarFieldEnum]): prisma_UserSubscription
  prisma_findFirstUserSubscriptionOrThrow(where: prisma_UserSubscriptionWhereInput, orderBy: [prisma_UserSubscriptionOrderByWithRelationInput], cursor: prisma_UserSubscriptionWhereUniqueInput, take: Int, skip: Int, distinct: [prisma_UserSubscriptionScalarFieldEnum]): prisma_UserSubscription
  prisma_findManyUserSubscription(where: prisma_UserSubscriptionWhereInput, orderBy: [prisma_UserSubscriptionOrderByWithRelationInput], cursor: prisma_UserSubscriptionWhereUniqueInput, take: Int, skip: Int, distinct: [prisma_UserSubscriptionScalarFieldEnum]): [prisma_UserSubscription]!
  prisma_aggregateUserSubscription(where: prisma_UserSubscriptionWhereInput, orderBy: [prisma_UserSubscriptionOrderByWithRelationInput], cursor: prisma_UserSubscriptionWhereUniqueInput, take: Int, skip: Int): prisma_AggregateUserSubscription!
  prisma_groupByUserSubscription(where: prisma_UserSubscriptionWhereInput, orderBy: [prisma_UserSubscriptionOrderByWithAggregationInput], by: [prisma_UserSubscriptionScalarFieldEnum]!, having: prisma_UserSubscriptionScalarWhereWithAggregatesInput, take: Int, skip: Int): [prisma_UserSubscriptionGroupByOutputType]!
  prisma_findUniqueUserSubscription(where: prisma_UserSubscriptionWhereUniqueInput!): prisma_UserSubscription
  prisma_findUniqueUserSubscriptionOrThrow(where: prisma_UserSubscriptionWhereUniqueInput!): prisma_UserSubscription
  prisma_queryRaw(query: String!, parameters: [String]): [_Row!]!
  prisma_queryRawJSON(query: String!, parameters: [String]): JSON
}

input prisma_UserApiLimitCreateInput {
  id: String
  userId: String!
  count: Int
  createdAt: DateTime
  updatedAt: DateTime
}

input prisma_StringFieldUpdateOperationsInput {
  set: String
}

input prisma_IntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input prisma_DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input prisma_UserApiLimitUpdateInput {
  id: prisma_StringFieldUpdateOperationsInput
  userId: prisma_StringFieldUpdateOperationsInput
  count: prisma_IntFieldUpdateOperationsInput
  createdAt: prisma_DateTimeFieldUpdateOperationsInput
  updatedAt: prisma_DateTimeFieldUpdateOperationsInput
}

input prisma_UserApiLimitCreateManyInput {
  id: String
  userId: String!
  count: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type prisma_AffectedRowsOutput {
  count: Int!
  _join: Query!
}

input prisma_UserApiLimitUpdateManyMutationInput {
  id: prisma_StringFieldUpdateOperationsInput
  userId: prisma_StringFieldUpdateOperationsInput
  count: prisma_IntFieldUpdateOperationsInput
  createdAt: prisma_DateTimeFieldUpdateOperationsInput
  updatedAt: prisma_DateTimeFieldUpdateOperationsInput
}

input prisma_UserSubscriptionCreateInput {
  id: String
  userId: String!
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
}

input prisma_NullableStringFieldUpdateOperationsInput {
  set: String
}

input prisma_NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input prisma_UserSubscriptionUpdateInput {
  id: prisma_StringFieldUpdateOperationsInput
  userId: prisma_StringFieldUpdateOperationsInput
  stripeCustomerId: prisma_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: prisma_NullableStringFieldUpdateOperationsInput
  stripePriceId: prisma_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: prisma_NullableDateTimeFieldUpdateOperationsInput
}

input prisma_UserSubscriptionCreateManyInput {
  id: String
  userId: String!
  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePriceId: String
  stripeCurrentPeriodEnd: DateTime
}

input prisma_UserSubscriptionUpdateManyMutationInput {
  id: prisma_StringFieldUpdateOperationsInput
  userId: prisma_StringFieldUpdateOperationsInput
  stripeCustomerId: prisma_NullableStringFieldUpdateOperationsInput
  stripeSubscriptionId: prisma_NullableStringFieldUpdateOperationsInput
  stripePriceId: prisma_NullableStringFieldUpdateOperationsInput
  stripeCurrentPeriodEnd: prisma_NullableDateTimeFieldUpdateOperationsInput
}

type Mutation {
  prisma_createOneUserApiLimit(data: prisma_UserApiLimitCreateInput!): prisma_UserApiLimit
  prisma_upsertOneUserApiLimit(where: prisma_UserApiLimitWhereUniqueInput!, create: prisma_UserApiLimitCreateInput!, update: prisma_UserApiLimitUpdateInput!): prisma_UserApiLimit
  prisma_createManyUserApiLimit(data: [prisma_UserApiLimitCreateManyInput]!, skipDuplicates: Boolean): prisma_AffectedRowsOutput
  prisma_deleteOneUserApiLimit(where: prisma_UserApiLimitWhereUniqueInput!): prisma_UserApiLimit
  prisma_updateOneUserApiLimit(data: prisma_UserApiLimitUpdateInput!, where: prisma_UserApiLimitWhereUniqueInput!): prisma_UserApiLimit
  prisma_updateManyUserApiLimit(data: prisma_UserApiLimitUpdateManyMutationInput!, where: prisma_UserApiLimitWhereInput): prisma_AffectedRowsOutput
  prisma_deleteManyUserApiLimit(where: prisma_UserApiLimitWhereInput): prisma_AffectedRowsOutput
  prisma_createOneUserSubscription(data: prisma_UserSubscriptionCreateInput!): prisma_UserSubscription
  prisma_upsertOneUserSubscription(where: prisma_UserSubscriptionWhereUniqueInput!, create: prisma_UserSubscriptionCreateInput!, update: prisma_UserSubscriptionUpdateInput!): prisma_UserSubscription
  prisma_createManyUserSubscription(data: [prisma_UserSubscriptionCreateManyInput]!, skipDuplicates: Boolean): prisma_AffectedRowsOutput
  prisma_deleteOneUserSubscription(where: prisma_UserSubscriptionWhereUniqueInput!): prisma_UserSubscription
  prisma_updateOneUserSubscription(data: prisma_UserSubscriptionUpdateInput!, where: prisma_UserSubscriptionWhereUniqueInput!): prisma_UserSubscription
  prisma_updateManyUserSubscription(data: prisma_UserSubscriptionUpdateManyMutationInput!, where: prisma_UserSubscriptionWhereInput): prisma_AffectedRowsOutput
  prisma_deleteManyUserSubscription(where: prisma_UserSubscriptionWhereInput): prisma_AffectedRowsOutput
  prisma_executeRaw(query: String!, parameters: [String]): Int!
}

scalar DateTime

scalar JSON

scalar UUID

scalar BigInt

scalar prisma_Bytes

type _Row {
  ID: ID!
  Int: Int!
  Float: Float!
  String: String!
  Boolean: Boolean!
  DateTime: DateTime!
  JSON: JSON!
  Object: _Row!
  Array: [_Row!]!
  OptionalID: ID
  OptionalInt: Int
  OptionalFloat: Float
  OptionalString: String
  OptionalBoolean: Boolean
  OptionalDateTime: DateTime
  OptionalJSON: JSON
  OptionalObject: _Row
  OptionalArray: [_Row!]
  _join: Query!
}

enum COMMON_REGEX_PATTERN {
  EMAIL
  DOMAIN
}

enum WG_ROLE {
  admin
  user
}

"""Well known claims - https://www.iana.org/assignments/jwt/jwt.xhtml"""
enum WG_CLAIM {
  """iss"""
  ISSUER
  """deprecated alias for ISSUER"""
  PROVIDER
  """sub"""
  SUBJECT
  """alias for sub"""
  USERID
  """name"""
  NAME
  """given_name"""
  GIVEN_NAME
  """family_name"""
  FAMILY_NAME
  """middle_name"""
  MIDDLE_NAME
  """nickname"""
  NICKNAME
  """preferred_username"""
  PREFERRED_USERNAME
  """profile"""
  PROFILE
  """picture"""
  PICTURE
  """website"""
  WEBSITE
  """email"""
  EMAIL
  """email_verified"""
  EMAIL_VERIFIED
  """gender"""
  GENDER
  """birthdate"""
  BIRTH_DATE
  """zoneinfo"""
  ZONE_INFO
  """locale"""
  LOCALE
  """location"""
  LOCATION
}

enum WunderGraphDateTimeFormat {
  "2006-01-02T15:04:05-0700"
  ISO8601
  "Mon Jan _2 15:04:05 2006"
  ANSIC
  "Mon Jan _2 15:04:05 MST 2006"
  UnixDate
  "Mon Jan 02 15:04:05 -0700 2006"
  RubyDate
  "02 Jan 06 15:04 MST"
  RFC822
  "02 Jan 06 15:04 -0700"
  RFC822Z
  "Monday, 02-Jan-06 15:04:05 MST"
  RFC850
  "Mon, 02 Jan 2006 15:04:05 MST"
  RFC1123
  "Mon, 02 Jan 2006 15:04:05 -0700"
  RFC1123Z
  "2006-01-02T15:04:05Z07:00"
  RFC3339
  "2006-01-02T15:04:05.999999999Z07:00"
  RFC3339Nano
  "3:04PM"
  Kitchen
  "Jan _2 15:04:05"
  Stamp
  "Jan _2 15:04:05.000"
  StampMilli
  "Jan _2 15:04:05.000000"
  StampMicro
  "Jan _2 15:04:05.000000000"
  StampNano
}